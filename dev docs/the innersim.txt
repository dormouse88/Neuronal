
CONSIDER: Neurons subsuming jumper functionality.
	Am I really happy with the distinction between neurons and jumpers? Have 'instant' neurons or 'OR input' jumpers?
	
	PROP: neurons can have 'delay' and 'numbers' as optional modules. Or properties that invisibly default to off.
		'Numbers' allows wire input weights and the threshold to be set (otherwise they all invisibly default to 1). Cosmetic difference only?
		'Delay' could either be a separate device with only that role, OR a neuron augmentation OR just a property of all neurons that defaults to off. Again Cosmetic difference only?

		PROP:
			Neurons that have all weights and thresholds as 1 are displayed with a more simple graphic.
			Neurons that have delay set to ON are drawn with a large bulb on the end.
		
		OBS: The two-segment neuron idea would fit into this nicely: The neuron itself can be coloured according to the calculated firing state while the delay bulb can be coloured according to the stored firing state.
		OBS: Old XML can be automatically converted to new (though there'll be loads more delay bulbs than necessary).
		
		CONSIDERATION: Implementing the charge propagation.
		Current Imp:
			PHASE ACT:
				(Push Inputs)
				Neuron - PushCharge
			PHASE CALC:
				Neuron - Sum charges to calculate firing bool
			ReceiveCharge:
				Neuron - add charge to receivedTotal
				Jumper - immediately calls PushCharge
		
		New Imp:
			PHASE ACT:
				Neuron - if (have bulb) PushCharge(bulbCharge); FireIfReady();
					<All inputless outputers (outergame inputs, neurons with no inputs, neurons delay bulbs) will respond with a PushCharge>
			PHASE CALC:
				Neuron - if (have bulb) bulb.adopt(); receivedChargeNum = 0; receivedChargeTotal = 0;
					<The charge of Neuron bulbs must not be changed during the main phase. Instead the next value of the bulb should be silently passed in. This value is then adopted in a separate phase>
			Neuron::FireIfReady() if (received all) { if (hasbulb) nextBulbCharge = charge, else pushCharge() };
			Neuron::ReceiveCharge() will store the accumulated total charge (as it does now) but also store the accumulated number of charges it has received.
				Each call, it checks if it has received from all its input wires and if so, it calculates its firing state by comparing the total received against the threshold and then propagates that firing state.

		Refresh Imp:
			Two "harmless" (as in, can be called excessively without negative consequence) functions - Refresh() and GetOutgoingCharge() - allow updating of non-time-dependent charges.
			Refresh() is called on "consequent" (to the right) elements to tell them they may have been affected by a change.
			GetOutgoingCharge() is used by refreshed elements and is called on their "antecedent" (to the left) elements to get data for the purposes of refreshment calculations.
			Refresh() can be freely called whenever a device is modified, etc. to allow instant charges to be immediately reflected.
			The only time-dependent activity is when Neuron delay bulbs use the "calc" and "act" phases just to update themselves and the brain xputs are changed.

			OBS: Cyclic dependencies of fast neurons will cause affected neurons to never fire. Maybe check for this and highlight it to the user. Simple to check, just iterate thru every device at the end of a tick and they should all have fired.
			OBS: Sending a 'false' charge is now very different from not sending any charge. Devices rely on counting all charges (including 'false') to know they are ready to calculate their own state.
		
	CONSIDERATION: Will feedback to the player about how the system is operating be better under the new or old way?
		CONC: The new way since it is a superset of the options available in the old way.



CONSIDER: Multichannel wires.
	To link multiple outputs of one plan to multiple inputs of another, user has to add multiple jumpers. That's not great. Also can't connect a neuron to multiple inputs or outputs without intermediary neurons.

	PROP:
		Wires are normal (single). wire selection is normal (single).
		Wiring plans can only happen when they are exploded, through selection of 'sockets' along the side. These are pseudo devices that are provided so there is always one spare.
		That solves everything!
		
			OBS: Although wiring and dewiring cannot occur when a plan is desploded, wires should maybe be drawn differently and multiple wires should be indicated.

			CONSIDERATION: Are sockets wired in?
				PROP: No!
			
			CONSIDERATION: Are sockets neurons? Do they 'OR' inputs or disallow multiple inputs?
				OPTION 1)
					Sockets are like jumpers and won't allow more than 1 input. They instantly pass on their charge.
				OPTION 2)
					Sockets are like default neurons and cannot have numbers or delay bulbs. This way they have 'OR' behaviour and so allow multi-in and multi-out which makes wiring rules simpler.
					Under the old charge system, OR behaviour would interfere with charge propagation. It could work under the new mostly-fast neuron system though, ... right?
					OBS: Unfortunately sockets will need state to remember at least if they have fired, if not also their cumulative charge + num of charges.
						Perhaps this state could be in ChipHandle/ChipPlan?
						PROP:
							Store two map<int, Socket> in ChipHandle, one each for inputs and outputs. Sockets are like unwired default neurons. The only state these have is with regard to charge and don't need serialization.
							On each ChipHandle::ReceiveCharge(), ChipHandle calls the Socket with the corresponding slot to pass it the charge and ask if it is ready to compute its fire value. When it is ready, ChipHandle passes it on to the ChipPlan with the slot value as usual.
							On each ChipPlan::ReceiveCharge(), the plan passes the charge to ChipHandle using StepOut() as usual. ChipHandle then calls (informs+queries) the appropriate output Socket.
							That way ChipHandle can contain and manage the input and output sockets. ChipPlan stays oblivious to the change.
						

CONSIDER: Named Slots.
	OBS: Handle-to-plan slot matching could work with names just the same as it does with numbers.
		When a charge is passed across plan/handle divide, the system currently looks for an exact match (slot 5 sends a signal to slot 5) on an int variable. This could just as easily be a string instead.
	OBS: An auto-name system like when saving plans could be used.
		When a new slot is created (by adding a wire) it is currently assigned the first available int. This could be made to be the first available capital letter instead (A,B,C,AB,AC,etc). This would provide an easy default value and also allow for a single, simple mechanic (just matching on exact string equality). Note that unlike with plan naming, "auto names" should not be denoted by a special symbol and are effectively not differentiated from real names.
	OBS: A plan/handle complex will draw a single interface "array" of slots. The slots in this array will be the union of the slots on the handle and the plan (sorted alphabetically).
	OBS: Interface: There must be a novel string input control. Controls to cycle up/down the slots are optional (if provided, the "end" could be the first available capital letter).
	OBS: Drawing: I guess having a fairly low maximum character limit is necessary to not take up too much space. Unless I use tooltips or something (nah).




